[{"categories":null,"contents":"What is Guard in Elixir In previous post, I explain what is Pattern Matching and how to use it.\nElixir pattern matching in a nutshell\nPattern matching is so cool but some time I want to do some more complicated checking. With pattern matching I can easily do this\n1def can_access?(%User{paid_user: true}), do: true Yes, Pattern matching can do check value with exact value easily. But for example, I want to allow user with level \u0026gt; 25 to access.\nHow to do that check with Pattern matching?\nPattern matching as it\u0026rsquo;s named, it is used to match data against pattern. If you want to do more complex check, you need another guy. That is where guard shines, it is complement for Pattern Matching\n1def can_access?(%User{level: level}) when level \u0026gt; 25, do: true What is guard   Guard is a complement to your pattern matching to do more complex check.\n  Guard expression is invoke after pattern mattching\n  In many cases, Guard and Pattern matching can produce the same result, so use which you like.\n  1# sum on empty list 2# pattern matching 3def sum_list([] = _input), do: 0 4 5# guard 6def sum_list(input) when input == [], do: 0 Some example\n  Check primitive type\n1def sum(a, b) when is_integer(a) and is_integer(b) do 2\ta + b 3end   Check value is nil/ not nil\n1def string_length(string) when not is_nil(string) do 2\t# your code 3end   Check if input in a list of allowed values\n1def can_edit?(%User{role: role}) when role in [\u0026#34;admin\u0026#34;, \u0026#34;moderator\u0026#34;] do 2\ttrue 3end   And many more \u0026hellip;\n  Where to use guard? Where you can use Pattern Matching, you can use Guard\n  case block\n1case value do 2\tx when is_binary(x) -\u0026gt; String.to_integer(x) 3\tx when is_integer(x) -\u0026gt; x 4\t_ -\u0026gt; raise \u0026#34;Invalid value\u0026#34; 5end   with block\n1with user when not is_nil(user) \u0026lt;- find_user(id) do 2\t# your code block 3end   function clause as our example above\n  Why my guard not work? Not all expression will work with guard. Only a list of built-in guard and combination of them work in guard expression.\nCheck this from https://hexdocs.pm/elixir/guards.html#list-of-allowed-expressions\n  comparison operators (==, !=, ===, !==, \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;=) strictly boolean operators (and, or, not). Note \u0026amp;\u0026amp;, ||, and ! sibling operators are not allowed as they\u0026rsquo;re not strictly boolean - meaning they don\u0026rsquo;t require arguments to be booleans arithmetic unary and binary operators (+, -, +, -, *, /) in and not in operators (as long as the right-hand side is a list or a range) \u0026ldquo;type-check\u0026rdquo; functions (is_list/1, is_number/1, etc.) functions that work on built-in datatypes (abs/1, map_size/1, etc.)   Can I define my own guard? Yes you can define a guard with defguard/1 and defguardp/1 . But you should only define your own guard if you have a really really reasonable reason to do so.\nIn my experience, I have never defined a guard my own, built-in guards are too enough.\nConclustion With Pattern matching and Guard, you have a super powerful combo in your hand. Let\u0026rsquo;s code!\n","date":"30","image":"/img/elixir-guard.webp","permalink":"https://onpoint.github.io/blog/2021-06-30-elixir-for-beginner-all-you-need-to-know-about-guard/","tags":["elixir","elixir-beginner"],"title":"Elixir for Beginner - All you need to know about guard"},{"categories":null,"contents":"If you are new to Elixir, Pattern Matching may be something strange to you. When you get familiar with it, you will know how powerful it is. And I\u0026rsquo;m sure that you will definite love it. Pattern matching is used everywhere in your elixlir code . And I would bring it to other language that I use ( if I can :D)\nBut it\u0026rsquo;s not so hard.\nWhat does Pattern Matching do? Give you a variable/value, you might want\n Check if data type is match your expected data type Check if structure of data match your expected data structure Assign matching part of data to a variable  And pattern matching do all these thing for you. Just look at some example.\nWhen you try these example, it will raise exception if data doesn\u0026rsquo;t match against the pattern. In real Elixir app, you won\u0026rsquo;t use it this way, check Where it is used at the end of this article\nPattern matching with Map/Struct 1. Check if this data is a map\n1%{} = params 2. Check if data is a map and has key email and email value is zoo@example.com\n1%{\u0026#34;email\u0026#34; =\u0026gt; \u0026#34;zoo@example.com\u0026#34;} = params 3. Check if data is a map and has key email, if matchs pattern, assign value of key email to variable my_email\n1%{\u0026#34;email\u0026#34; =\u0026gt; my_email} = params 4. Check if data is a map and has key email, I don\u0026rsquo;t want to extract value\nuse _ to ignore value\n1%{\u0026#34;email\u0026#34; =\u0026gt; _} = params 5. Pattern matching nested map\n1%{\u0026#34;address\u0026#34; =\u0026gt; %{\u0026#34;city\u0026#34; =\u0026gt; city}} = params 6. Check if data is type struct User\n1%User{} = params  The rest is same with map. Struct is basically a map with atom key.\n Pattern matching with List 1. Check if data is empty lis\n1[] = params 2. Check if data is a list and not empty\n1[_|_] = params 3. Check if data is exact list\n1[1, 2] = params 4. Check if data is list and extract first element and remaining\n1[first_element | remaining] = params Pattern matching with Tuple You don\u0026rsquo;t have much pattern to match against tuple\n1. Check if data is tuple of 2 elements\n1{_, _} = params 2. Check if data is tuple and has specific value\n1{:ok, data} = result 2# you use this most of time Where to use pattern matching 1. case clause\n1case user do 2\t%User{is_active: true} -\u0026gt; \u0026#34;Log you in\u0026#34; 3\t%User{is_active: false} -\u0026gt; \u0026#34;Check your email\u0026#34; 4\t_others -\u0026gt; \u0026#34;Not a user\u0026#34; 5end 2. with clause\n1with {:ok, user} \u0026lt;- create_user(params) do 2\t# your code 3end 3. function\n1def is_admin(%User{role: \u0026#34;admin\u0026#34;}), do: true 2def is_admin(%User{role: _}), do: false 3def is_admin(_), do: raise \u0026#34;Not a user\u0026#34; Conclusion At first, it\u0026rsquo;s a bit strange to grasp, but gradually you can live without it. It is one of Elixir\u0026rsquo;s features that I love most. And I think you will. Using it more and its power is in your hand.\n","date":"29","image":"/img/pattern-matching.png","permalink":"https://onpoint.github.io/blog/2021-06-29-elixir-pattern-matching-in-a-nut-shell/","tags":["elixir","elixir-beginning"],"title":"Elixir Pattern Matching in a nut shell"},{"categories":null,"contents":"The story At our company, OnPoint, we are building an ecommerce website using Phoenix Framework. And I am working on admin to manage product, orders \u0026hellip; All the listing pages need a filter and this filter change frequently, operation team wants to add this field, order by that field. And each time they change their requirements I have to update query code.\nMy team use Django Admin before, they support an easy way to compose query directly from the URL. You don\u0026rsquo;t have to change code on the back-end. It\u0026rsquo;ll be great if I can do it with Phoenix.\nWhat it should have:\n Support basic query operator: \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;=, =, !=, like, ilike, in Query join table Can sort result  This is the result after some night of work:\nhttps://github.com/bluzky/querie\nHow it work  I define a simple rule for passing parameter from client side. The key must follow format [column]__[operator]=[value]. On the server side, it is parsed to {operator, {column, value}} with appropriate data type Then it is passed to a filter function to build Ecto query dynamically  You can try with example project to see how it works.\nHow to use it 1. Define a filter schema For example you have a Post schema:\n1defmodule Example.Content.Post do 2 use Ecto.Schema 3 import Ecto.Changeset 4 5 def state_enum(), do: ~w(draft published archived trash) 6 7 schema \u0026#34;posts\u0026#34; do 8 field(:content, :string) 9 field(:state, :string, default: \u0026#34;draft\u0026#34;) 10 field(:title, :string) 11 field(:view_count, :integer, default: 0) 12 belongs_to(:category, Example.PostMeta.Category) 13 belongs_to(:author, Example.Account.User) 14 end 15end And you want to filter the Post by title, state, view_count. This is the filter schema:\n1@schema %{ 2 title: :string, 3 state: :string, # short form 4 view_count: [type: :integer] # long form 5} 2. Parse request parameters and build the query Use Querie.parse/2 to parse request parameters with your schema\n1alias Example.Content.Post 2 3def index(conn, params) do 4 with {:ok, filter} \u0026lt;- Querie.parse(@schema, params) do 5\tquery = Querie.filter(Post, filter) 6\t# Or you can pass a query like this 7\t# query = from(p in Post, where: ....) 8\t# query = Querie.filter(query, filter) 9\tposts = Repo.all(query) 10\t# do the rendering here 11 else 12 {:error, errors} -\u0026gt; 13\tIO.puts(inspect(errors) 14\t# or do anything with error 15\t# error is a list of tuple {field, message} 16 end 17end 3. Compose URL Then from client side you can send a form:\n1\u0026lt;form action=\u0026#34;/posts\u0026#34;\u0026gt; 2 \u0026lt;label\u0026gt;Titlte\u0026lt;/label\u0026gt; 3 \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title__icontains\u0026#34;\u0026gt; 4 \u0026lt;label\u0026gt;State\u0026lt;/label\u0026gt; 5 \u0026lt;select name=\u0026#34;state\u0026#34;\u0026gt; 6 \u0026lt;option value=\u0026#34;draft\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; 7 \u0026lt;option value=\u0026#34;published\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; 8 \u0026lt;option value=\u0026#34;trashed\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; 9 \u0026lt;/select\u0026gt; 10 \u0026lt;label\u0026gt;View count greater than\u0026lt;/label\u0026gt; 11 \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;view_count__ge\u0026#34;\u0026gt; 12\u0026lt;/form\u0026gt; Or directly from URL with data like this:\nhttp://localhost:4000/posts?title__icontains=elixir\u0026amp;state=published\u0026amp;view_count__ge=100 Enter and see the result\nQuery joined table It quite simple to filter result with filter on joined tables.\n1. Update your query Querie support ref operator to join tables. For example you want to query Post by author whose email contains sam the query would be:\n?author__ref[email__icontains]=sam 2. Update your schema 1alias Example.Account.User 2 3@schema %{ 4 title: :string, 5 state: :string, 6 view_count: [type: :integer], 7 author: [ 8\ttype: :ref, # this references to another schema 9\tmodel: User, # which schema to query 10\tschema: %{ # define filter schema for User 11\temail: :string 12\t} 13\t] 14} For more query options, please read document\nIf you have any suggestion, please leave a comment or open an issuse on Github.\nThanks for reading.\n","date":"30","image":"/img/request-to-query.png","permalink":"https://onpoint.github.io/blog/2020-10-30-compose-ecto-query-from-client/","tags":["elixir","phoenix","query","ecto","querie"],"title":"Compose Ecto Query From Client"},{"categories":null,"contents":"Yêu cầu chuẩn hoá và validate các tham số truyền lên từ client là yêu cầu cơ bản khi xây dựng API Web. Mình đã có một bài hướng dẫn sử dụng Ecto.Changeset để chuẩn hoá trong bài viết này:\nParse và validate request param trong Phoenix với Ecto \nTrong bài viết này, mình sẽ hướng dẫn một cách ngắn và đơn giản hơn bằng cách sử dụng thư viện sẵn có Tarams. Thư viện này thực ra là sử dụng lại Ecto.Changeset nhưng nó giúp cho chúng ta không phải lặp lại quá nhiều code như khi dùng Ecto.Changeset\nMột vài tính năng thú vị của Tarams:\n Cung cấp cách thức đơn giản để định nghĩa các cấu trúc tham số Cho phép định nghĩa các giá trị default động Cho phép định nghĩa các hàm để cast giá trị về đúng kiểu dữ liệu Định nghĩa hàm để validate dữ liệu  Sau đây là cách sử dụng Tarams. Ví dụ chúng ta đang viết API để cập nhật profile của nhân viên. Yêu cầu là\nemail: bắt buộc, đúng định dạng first_name: bắt buộc last_name: bắt buộc birthday: không bắt buộc, kiểu ngày tháng title: không bắt buộc start_date: ngày bắt đầu làm việc, ngày tháng, mặc định là ngày hiện tại 1. Định nghĩa cấu trúc của tham số truyền lên khá đơn giản 1@schema %{ 2 email: [type: :string], 3 first_name: [type: :string], 4 last_name: [type: :string], 5 title: :string, 6 birth_day: [type: :date], 7 start_date: [type: :date] 8} Schema đơn giản chỉ là một map với key là tên field và value là 1 list option của field đó.\n2. Bây giờ thêm các ràng buộc  Để đánh dấu 1 trường là bắt buộc, thêm option required: true Taram cũng cho phép validate data sử dụng lại các hàm validate của Changeset  1@schema %{ 2 email: [type: :string, required: true, validate: {:format, ~r/@/}], 3 first_name: [type: :string, required: true], 4 last_name: [type: :string, required: true], 5 title: :string, 6 birth_day: [type: :date], 7 start_date: [type: :date] 8} 3. Bây giờ thì set các giá trị default default có thể là 1 giá trị hoặc 1 hàm. Mỗi khi parse tham số thì hàm này sẽ được gọi để lấy giá trị mặc định\n1@schema %{ 2 ... 3 title: [type: :string, default: \u0026#34;staff\u0026#34;], 4 birth_day: [type: :date], 5 start_date: [type: :date, default: \u0026amp;Timex.today/0] 6} 4. Cast các giá trị tham số về đúng kiểu Nhiều các giá trị tham số truyền lên phải được chuyển về đúng các loại dữ liệu phức tạp như ngày tháng, list. Ví dụ ngày tháng truyền lên là string 01/12/1994 thì phải chuyển về kiểu date để sử dụng lại được. Tarams hỗ trợ định nghĩa 1 hàm custom để cast giá trị, hàm này trả về\n {:ok, value} nếu parse thành công {:error, error_message} nếu thất bại  1def parse_date(date_str) do 2 Timex.parse(date_str, \u0026#34;{0D}/{0M}/{YYYY}\u0026#34;) 3end 4 5@schema %{ 6 ... 7 title: [type: :string, default: \u0026#34;staff\u0026#34;], 8 birth_day: [type: :date, cast_func: \u0026amp;parse_date/1], 9 start_date: [type: :date, default: \u0026amp;Timex.today/0] 10} 5. Bây giờ sử dụng nào 1def update(conn, params) do 2 with {:ok, user_data} \u0026lt;- Tarams.parse(@schema, params) do 3 # do anything with your params 4 # access data bằng atom key: user_data.email 5 else 6 {:error, changset} -\u0026gt; # return params error 7 end 8end Hàm parse sẽ parse và validate dữ liệu. Nếu mọi thứ đều ổn, sẽ trả về {:ok, data} và ngược lại thì trả về {:error, changeset}.\nDone! Code của bạn sẽ trở nên đơn giản và ngắn gọn hơn nhiều\n","date":"01","image":"/img/tarams-parse.png","permalink":"https://onpoint.github.io/blog/2020-10-01parse-validate-data-with-tarams/","tags":["elixir","ecto","phoenix","tarams"],"title":"Chuẩn hoá và validate dữ liệu trong Phoenix với thư viện Tarams"},{"categories":null,"contents":"Khi viết các API hoặc cả các endpoint thì thông thường chúng ta sẽ có một số nhu cầu:\n Chỉ cho phép một số các tham số xác định được truyền vào. Chuyển các tham số về kiểu dữ liệu mong muốn Validate các tham số theo yêu cầu  Bài viết này sẽ hướng dẫn các bạn giải quyết các vấn đề trên sử dụng Ecto.Changeset\nThư viện Ecto đã cung cấp sẵn cho chúng ta module Changeset. Nó hỗ trợ việc cast các tham số về đúng kiểu dữ liệu mong muốn, nó cũng hỗ trợ các phương thức để validate các tham số yêu cầu, và nó cũng cho phép bạn giới hạn tham số nào được truyền vào.\nVà sau đây là một ví dụ sử dụng Chageset để validate các tham số khi filter các đơn hàng.\n1. Đầu tiên bạn phải định nghĩa một schema 1defmodule MyApp.OrderFilterParams do 2 use Ecto.Schema 3 import Ecto.Changeset 4 5 schema \u0026#34;order_filter_params\u0026#34; do 6 field :keyword, :string 7 field :category_id, :integer 8 field :status, :string 9 field :start_date, :utc_datetime 10 field :end_date, :utc_datetime 11 end 12end 2. Cast và validate Sau đó phải định nghĩa một hàm để thực hiện việc cast tham số và validate changeset.\n1defmodule MyApp.OrderFilterParams do 2 3 ... 4 5 @required ~w(category_id start_date) 6 @optional ~w(keyword status end_date) 7 8 def changeset(changeset_or_model, params) do 9 cast(changeset_or_model, params, @required ++ @optional) 10 |\u0026gt; validate_required(@required) 11 end 12end 3. Set giá trị default động Nếu bạn muốn sử dụng các giá trị default động, ví dụ như mặc định ngày kết thúc là ngày hiện tại, các bạn phải định nghĩa một function để set giá trị mong muốn.\n1defmodule MyApp.OrderFilterParams do 2 3 ... 4 5 def changeset(changeset_or_model, params) do 6 cast(changeset_or_model, params, @required ++ @optional) 7 |\u0026gt; validate_required(@required) 8 |\u0026gt; set_default_end_date() 9 end 10 11 defp set_defaut_end_date(changeset) do 12 end_date = get_change(changeset, :end_date) 13 if is_nil(end_date) do 14 put_change(changeset, :end_date, Timex.today()) 15 else 16 changeset 17 end 18 end 19end 4. Sử dụng Params schema 1defmodule MyApp.OrderController do 2 use MyApp, :controller 3 alias MyApp.OrderFilterParams 4 5 def index(conn, params) do 6 changeset = OrderFilterParams.changeset(%OrderFilterParams{}, params) 7 8 if changeset.valid? do 9 strong_params = Ecto.Changeset.apply_changes(changeset) 10\tIO.put(strong_params.keyword) 11 # Do something with your params 12 else 13 # handle error 14 end 15 end 16end 17 Rất đơn giản đúng không, nếu bạn đã sử dụng Ecto thì việc này chỉ là ruồi muỗi. Tuy nhiên đơn giản thì phải có thứ đánh đổi chứ.\nVài thứ mà bạn sẽ thấy bất tiện 1. Lượng code mà bạn phải viết quá nhiều. Thử tưởng tượng mỗi API bạn lại phải định nghĩa thêm một Module params cho nó thì phức tạp vl.\nBạn có thể sử dụng schemaless, nhưng mà function của bạn sẽ rối nùi lên vì code logic và code xử lý params nó không liên quan gì tới nhau cả. Và bạn thì kiểu như đổ sting vào cơm để ăn vậy.\n2. Thiếu linh hoạt. Điều này cũng đúng vì mục đích chính của Ecto là phục vụ cho việc định nghĩa các schema cho database.\nĐơn giản như việc định nghĩa giá trị default động như trên, bạn phải viết luôn 1 hàm mới\nTuy nhiên nó cũng có một ưu điểm là bạn không phải sử dụng thêm thư viện của bên thứ ba.\nKết Nếu bạn không cần phải xử lý nhiều ràng buộc liên quan đến tham số của request thì đơn giản là cứ dùng Changeset thôi.\nNếu bạn muốn nhanh gọn hơn thì trên Hex có một số thư viện để hỗ trợ định nghĩa param đơn giản hơn, ví dụ như https://github.com/bluzky/tarams/\nThư viện này cung cấp cách thức đơn giản và nhanh chóng hơn để định nghĩa param cho API. Mình sẽ viết bài hướng dẫn sau.\n","date":"26","image":"/img/parse-ecto-phoenix.png","permalink":"https://onpoint.github.io/blog/validate-request-params-phoenix-ecto/","tags":["elixir","ecto","phoenix"],"title":"Parse và validate request param trong Phoenix với Ecto"}]