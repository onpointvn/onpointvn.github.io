[{"categories":null,"contents":"If your data is encrypted, even if it\u0026rsquo;s leaked, no one know what is the data. That\u0026rsquo;s great.\nIn this post, I\u0026rsquo;m going to show you how to encrypt data with Ecto. Ecto allows developer to define their own types. And we will define a type called EncryptedText which encrypts data before persiting to database and decrypts data after loading.\n1. Define encrypt/decrypt methods This is a simple version of crypto module:\n1defmodule Crypto do 2 @block_size 16 3 4 def generate_secret do 5 :crypto.strong_rand_bytes(@block_size) 6 |\u0026gt; Base.encode64() 7 end 8 9 def encrypt(plaintext, secret_key) do 10 with {:ok, secret_key} \u0026lt;- decode_key(secret_key) do 11 iv = :crypto.strong_rand_bytes(@block_size) 12 plaintext = pad(plaintext, @block_size) 13 ciphertext = :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, plaintext, true) 14 15 {:ok, Base.encode64(iv \u0026lt;\u0026gt; ciphertext)} 16 end 17 end 18 19 def decrypt(ciphertext, secret_key) do 20 with {:ok, secret_key} \u0026lt;- decode_key(secret_key), 21 {:ok, \u0026lt;\u0026lt;iv::binary-@block_size, ciphertext::binary\u0026gt;\u0026gt;} \u0026lt;- Base.decode64(ciphertext) do 22 plaintext = 23 :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, ciphertext, false) 24 |\u0026gt; unpad 25 26 {:ok, plaintext} 27 else 28 {:error, _} = err -\u0026gt; err 29 _ -\u0026gt; {:error, \u0026#34;Bad encrypted data\u0026#34;} 30 end 31 end 32 33 defp pad(data, block_size) do 34 to_add = block_size - rem(byte_size(data), block_size) 35 data \u0026lt;\u0026gt; :binary.copy(\u0026lt;\u0026lt;to_add\u0026gt;\u0026gt;, to_add) 36 end 37 38 defp unpad(data) do 39 to_remove = :binary.last(data) 40 :binary.part(data, 0, byte_size(data) - to_remove) 41 end 42end Let go through the code\n1 def generate_secret do 2 :crypto.strong_rand_bytes(@block_size) 3 |\u0026gt; Base.encode64() 4 end This function generate a 16 bytes secret key and encode base 64 string so you can add it to config.\n encrypt/2 function  1 def encrypt(plaintext, secret_key) do 2 # check the key size 3 with {:ok, secret_key} \u0026lt;- decode_key(secret_key) do 4 5 # random initial vector 6 iv = :crypto.strong_rand_bytes(@block_size) 7 # if length of text is not multiple of @block_size 8 # we add more data until it meets condition 9 plaintext = pad(plaintext, @block_size) 10 # encrypt here 11 ciphertext = :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, plaintext, true) 12 13 {:ok, Base.encode64(iv \u0026lt;\u0026gt; ciphertext)} 14 end 15 end This is the most important line\n1ciphertext = :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, plaintext, true)  iv is initial vector. AES-128 algorithms encrypts data by block of 16 bytes, so we need initial vector to make sure that the output of blocks with same data are different from each other. The last parameter is set to true to encrypt, set to false to decrypt data  And then we encode output to base 64 string. Here we concatenate iv and ciphertext so that we can extract iv to use for decrypting\n1{:ok, Base.encode64(iv \u0026lt;\u0026gt; ciphertext)}  decrypt/2 function  1def decrypt(ciphertext, secret_key) do 2 # check the key 3 with {:ok, secret_key} \u0026lt;- decode_key(secret_key), 4 {:ok, \u0026lt;\u0026lt;iv::binary-@block_size, ciphertext::binary\u0026gt;\u0026gt;} \u0026lt;- Base.decode64(ciphertext) do 5 plaintext = 6 :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, ciphertext, false) 7 |\u0026gt; unpad 8 9 {:ok, plaintext} 10 else 11 {:error, _} = err -\u0026gt; err 12 _ -\u0026gt; {:error, \u0026#34;Bad encrypted data\u0026#34;} 13 end 14 end We extract iv and encrypted data from input\n1{:ok, \u0026lt;\u0026lt;iv::binary-@block_size, ciphertext::binary\u0026gt;\u0026gt;} \u0026lt;- Base.decode64(ciphertext) We use pattern matching to extract first 16 byte and assign to iv and assign remaining data to ciphertext. Then decrypting data\n1plaintext = 2 :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, ciphertext, false) 3 |\u0026gt; unpad This line is similar to the line which encrypts data, the difference is here we replace plaintext by ciphertext and last parameter is set to false. After data is decrypted, we need to remove padding to get the original data.\n2. Build EncryptedText type I define a type to store binary data, you can define a EncryptedMap to store map data. The most important function are dump and load where we encrypt before persisting and decrypt after loading.\n1defmodule EncryptedText do 2 use Ecto.Type 3 4 # we store data as string 5 def type, do: :string 6 7 def cast(value) when is_binary(value) do 8 {:ok, value} 9 end 10 def cast(_), do: :error 11 12 def dump(nil), do: nil 13 # encrypt data before persist to database 14 def dump(data) when is_binary(data) do 15 with {:ok, secret_key} \u0026lt;- Application.fetch_env(:myapp, :ecto_secret_key), 16 {:ok, data} \u0026lt;- Crypto.encrypt(data, secret_key) do 17 {:ok, data} 18 else 19 _ -\u0026gt; :error 20 end 21 end 22 23 def dump(_), do: :error 24 25 def load(nil), do: nil 26 # decrypt data after loaded from database 27 def load(data) when is_binary(data) do 28 secret_key = Application.fetch_env!(:myapp, :ecto_secret_key) 29 case Crypto.decrypt(data, secret_key) do 30 {:error, _} -\u0026gt; :error 31 ok -\u0026gt; ok 32 end 33 end 34 35 def load(_), do: :error 36 37 def embed_as(_), do: :dump 38end 39 3. Use it in your schema  You must add secret key to your app config first.  1config :myapp, :ecto_secret_key, \u0026#34;your key using Crypto.generate_secret\u0026#34;  Add to schema  1schema \u0026#34;users\u0026#34; do 2 field :name, :string 3 ... 4 field :secret, EncryptedText 5 ... 6end Your data are safe now.\n4. Conclusion With Crypto you can implement encrypted field for any type of data you want.\nThere is an issue when you want to change your secret key, you have to load your data row by row, decrypt and then encrypt with new key and update to database.\nI found this article which explains very well about crypto if you are interested https://www.thegreatcodeadventure.com/elixir-encryption-with-erlang-crypto/ Although she uses old crypto API so it will throw some warnings.\nI implemented encrypted type for text and map for my company project here if you want to use it:\nGithub\nThanks for reading.\n","date":"20","image":"/img/encrypt-data-ecto.png","permalink":"https://techblog.onpoint.vn/blog/2021-08-20-encrypt-data-with-ecto/","tags":["elixir","ecto","crypto"],"title":"How to encrypt your data with Ecto"},{"categories":null,"contents":" Credit: filter image taken from svgrepo.com\n In web developments, server receives lots of request data from client side. And when working with request params from client, my first rule is:\n Don\u0026rsquo;t believe the client\n Imagine that you provide API to list all post using the filter from client, and user may add user_id which point to other user, and you don\u0026rsquo;t remove that unexpected field from request params. If you don\u0026rsquo;t handle your logic carefully, you may accidentally leak data.\nSo every request should be cleaned from unexpected params, casted to the proper data type, and validated before passing to business layer.\nYou can achieve this by:\nUsing Ecto If you are building a web server using Phoenix, I guess Ecto is already in your dependencies. Just use it.\nThank to Ecto schemaless, you can build changeset from a dynamic schema:\n1defmodule MyApp.PostController do 2 ... 3 defp index_params(params) do 4 default = %{ 5 status: nil, 6 q: nil, 7 is_published: true 8 } 9 10 types = %{ 11 status: :string, 12 q: :string, 13 is_published: :boolean 14 } 15 16 changeset = 17 {default, types} 18 |\u0026gt; Ecto.Changeset.cast(params, Map.keys(types)) 19 20 if changeset.valid? do 21 {:ok, Ecto.Changeset.apply_changes(changeset)} 22 else 23 {:error, changeset} 24 end 25 end 26 27 def index(conn, params) do 28 with {:ok, valid_params} \u0026lt;- index_params(params) do 29 # do your logic 30 end 31 end 32 ... 33end With Ecto you can do validation on your params as you do with your schema changeset.\nThis way is simple and most of you are familiar with it. But you have to write much code and cannot cast and validate nested params.\nUse library Tarams This library provide a simple way to define schema. Let\u0026rsquo;s rewrite example above using tarams.\nFirst add this to your dependency list:\n{:tarams, \u0026quot;~\u0026gt; 1.0.0\u0026quot;} 1defmodule MyApp.PostController do 2 ... 3 @index_params %{ 4 status: :string, 5 q: :string 6 is_published: [type: :boolean, default: true], 7 page: [type: :integer, number: [min: 1]], 8 size: [type: :integer, number: [min: 10, max: 100]] 9 } 10 def index(conn, params) do 11 with {:ok, valid_params} \u0026lt;- Tarams.cast(params, @index_params) do 12 # do your logic 13 end 14 end 15 ... 16end And it support nested params too\n1defmodule MyApp.PostController do 2 ... 3 @create_params %{ 4 title: [type: :string, required: true], 5 content: [type: :string, required: true], 6 tags: [type: {:array, :string}], 7 published_at: :naive_datetime, 8 meta: %{ 9 tile: :string, 10 description: :string, 11 image: :string 12 } 13 } 14 def create(conn, params) do 15 with {:ok, valid_params} \u0026lt;- Tarams.cast(params, @create_params) do 16 MyApp.Content.create_post(valid_params) 17 end 18 end 19 ... 20end Conclusion All request params should be casted and validated at controller. Then you only work with data that you know what it is, and you don\u0026rsquo;t have to worry about unexpected parameters.\nThanks for reading, hope it can helps.\n","date":"14","image":"/img/validate-request-params.png","permalink":"https://techblog.onpoint.vn/blog/2021-08-14-validate-request-params-with-phoenix/","tags":["elixir","phoenix","param validation"],"title":"How to validate request params in Phoenix"},{"categories":null,"contents":" Credit: this icon is from flaticon.com\n In previous article, I shown you how to implement you own validation module. I you haven\u0026rsquo;t read it, you can find it here How to build an Elixir validator from scratch \nAnd I think some of you may want a ready to use library so I wrapped it up, added some useful api and published on hex.pm and github repo here.\nThis post is just showcases of what it can do. (not too much fancy) First, add dependencies to your mix.exs and you are ready to go.\n1{:valdi, \u0026#34;~\u0026gt; 0.2.0\u0026#34;} And this is how it works.\nValidate using a specific validation function\n1iex(1)\u0026gt; age = 20 220 3iex(2)\u0026gt; Valdi.validate_number(age, min: 18, max: 60) 4:ok But most of the time you don\u0026rsquo;t do this, you will want to combine multiple validations at a time.\n1iex(4)\u0026gt; Valdi.validate(\u0026#34;20\u0026#34;, type: :integer, number: [min: 18, max: 60]) 2{:error, \u0026#34;is not a integer\u0026#34;} And you may want to validate a list of value too:\n1iex(1)\u0026gt; Valdi.validate_list([\u0026#34;hi\u0026#34;, \u0026#34;how\u0026#34;, \u0026#34;are\u0026#34;, \u0026#34;you\u0026#34;, 100], type: :string, length: [min: 3]) 2{:error, 3 [[0, \u0026#34;length must be greater than or equal to 3\u0026#34;], [4, \u0026#34;is not a string\u0026#34;]]} If validation failed, you got a list of error and index of error item.\nValdi supports you to validate a simple map with given specification:\n1product_spec = %{ 2 name: [type: :string, required: true], 3 sku: [type: :string, required: true], 4 price: [type: :integer, number: [min: 0]] 5} 6Valdi.validate_map(%{ 7 name: \u0026#34;A magic pen\u0026#34;, 8 sku: nil, 9 price: -1 10}, product_spec) 11 12# {:error, %{price: \u0026#34;must be greater than or equal to 0\u0026#34;, sku: \u0026#34;is required\u0026#34;}} Valdi does not support nested map validation.\nYou might want to take a look at Contrak, it extended Valdi by providing a simple way to define and validate nested schema.\nWhy I didn\u0026rsquo;t put those in just one library? I think data validation and schema validation are quite different, so I want to keep libraries simple and do its best thing.\nHere you can define your own validation\n1Valdi.validate(\u0026#34;as008x8234\u0026#34;, type: :string, func: fn value -\u0026gt; 2 if String.match?(value, ~r/^\\d{4}$/), do: :ok, else: {:error, \u0026#34;not a year string\u0026#34;} 3end) 4 5# {:error, \u0026#34;not a year string\u0026#34;} Hope this small library can help. If you have any suggestion please comment. Thank you.\n","date":"06","image":"/img/valdi-data-validator.webp","permalink":"https://techblog.onpoint.vn/blog/2021-08-06-valdi-elixir-validator/","tags":["elixir","validation"],"title":"Easy data validation with with Valdi in Elixir"},{"categories":null,"contents":"Validation is a must have part of web application. You have to validate request parameter before processing, you validate data before inserting to database, and many more.\nNormally, I use Ecto.Changeset to do validation job. But it comes with changeset, I have to build schema, changeset then do the validation. Sometime you just don\u0026rsquo;t need too much thing like that.\nSo today we are going to build a simple validation module to use without changeset, or in some project you don\u0026rsquo;t use Ecto, or just for learning.\nWhat our validation module includes:  Type validation Number validation Length validation for map, list, string String format validation using regex Inclusion, exclusion validations  That\u0026rsquo;s is quite enough, you can define more if you want. And the module will support a simple API to validate a value\n1validate(value::any(), validations::keyword()) :: :ok | {:error, String.t()} Let\u0026rsquo;s start.\nType validation Let\u0026rsquo;s call our module Checky. Type check is quite straight forward. Elixir support most of type check guard that we need:\n1defmodule Checky do 2 def validate_type(value, :boolean) when is_boolean(value), do: :ok 3 def validate_type(value, :integer) when is_integer(value), do: :ok 4 def validate_type(value, :float) when is_float(value), do: :ok 5 def validate_type(value, :number) when is_number(value), do: :ok 6 def validate_type(value, :string) when is_binary(value), do: :ok 7 def validate_type(value, :binary) when is_binary(value), do: :ok 8 def validate_type(value, :tuple) when is_tuple(value), do: :ok 9 def validate_type(value, :array) when is_list(value), do: :ok 10 def validate_type(value, :list) when is_list(value), do: :ok 11 def validate_type(value, :atom) when is_atom(value), do: :ok 12 def validate_type(value, :function) when is_function(value), do: :ok 13 def validate_type(value, :map) when is_map(value), do: :ok 14 # we will add some more validation here 15 def validate_type(_, type), do: {:error, \u0026#34;is not a #{type}\u0026#34;} 16end Easy, right? Now let\u0026rsquo;s support checking for struct:\n1defmodule Checky do 2 3 ... 4 # from Elixir 1.12 you can do this 5 def validate_type(value, struct_name) when is_struct(value, struct_name), do: :ok 6 # this is for Elixir before 1.12 7 def validate_type(%{__struct__: struct}, struct_name) when struct == struct_name, do: :ok 8 ... 9end  Here we check for keyword  1defmodule Checky do 2 ... 3 # empty list is also a empty keyword 4 def validate_type([] = _check_item, :keyword), do: :ok 5 # if list item is a tuple of 2 and first element is atom then it is a keyword list 6 def validate_type(items, :keyword) when is_list(items) do 7 valid? = Enum.all(item, fn 8 {key, _} when is_atom(key) -\u0026gt; true 9 _ -\u0026gt; false 10 end) 11 12 if valid? do 13 :ok 14 else 15 {:error, \u0026#34;is not a keyword\u0026#34;} 16 end 17 end 18 ... 19end  Now let support array check {:array, type} which is similar to Ecto.Schema.  1defmodule Checky do 2 ... 3 def validate_type(value, {:array, type}) when is_list(value) do 4 # We will check type for each value in the list 5 array(value, \u0026amp;validate_type(\u0026amp;1, type)) 6 end 7 ... 8 # loop and validate element in array using `validate_func` 9 defp array(data, validate_func) 10 11 defp array([], _) do 12 :ok 13 end 14 15 # validate recursively, and return error if any vadation failed 16 defp array([h | t], validate_func) do 17 case validate_func.(h) do 18 :ok -\u0026gt; 19 array(t, validate_func) 20 err -\u0026gt; 21 err 22 end 23 end 24end Phew! We have done with type validation. You can add more type validation if you want.\nFormat Validation This validation is super easy, Regex do that for us:\n1defmodule Checky end 2 def validate_format(value, check) when is_binary(value) do 3 if Regex.match?(check, value), do: :ok, else: {:error, \u0026#34;does not match format\u0026#34;} 4 end 5 6 def validate_format(_value, _check) do 7 {:error, \u0026#34;format check only support string\u0026#34;} 8 end 9end Inclusion and exclusion validation These are trivial checks too. Just make sure it is implement Enumerable protocol.\n1defmodule Checky do 2 def validate_inclusion(value, enum) do 3 if Enumerable.impl_for(enum) do 4 if Enum.member?(enum, value) do 5 :ok 6 else 7 {:error, \u0026#34;not be in the inclusion list\u0026#34;} 8 end 9 else 10 {:error, \u0026#34;given condition does not implement protocol Enumerable\u0026#34;} 11 end 12 end 13 14 @doc \u0026#34;\u0026#34;\u0026#34; 15Check if value is **not** included in the given enumerable. Similar to `validate_inclusion/2` 16\u0026#34;\u0026#34;\u0026#34; 17 def validate_exclusion(value, enum) do 18 if Enumerable.impl_for(enum) do 19 if Enum.member?(enum, value) do 20 {:error, \u0026#34;must not be in the exclusion list\u0026#34;} 21 else 22 :ok 23 end 24 else 25 {:error, \u0026#34;given condition does not implement protocol Enumerable\u0026#34;} 26 end 27 end 28end Number validation This is one of the most complicated part of our module. It\u0026rsquo;s not difficult, it\u0026rsquo;s just long. We will support following checks:\n equal_to greater_than_or_equal_to | min greater_than less_than less_than_or_equal_to | max  And it should support multiple check like this:\n1 validate_number(x, [min: 10, max: 20]) First we code validation function for single condition like this\n1 def validate_number(number, {:equal_to, check_value}) do 2 if number == check_value do 3 :ok 4 else 5 {:error, \u0026#34;must be equal to #{check_value}\u0026#34;} 6 end 7 end As I said, it\u0026rsquo;s so simple. You can fill the remaining check right? Or you can check the final code at the end of the post. After implementing all validation fucntion for number, it\u0026rsquo;s time to support multiple condtion check.\n1 @spec validate_number(integer() | float(), keyword()) :: :ok | error 2 def validate_number(value, checks) when is_list(checks) do 3 if is_number(value) do 4 checks 5 |\u0026gt; Enum.reduce(:ok, fn 6 check, :ok -\u0026gt; 7 validate_number(value, check) 8 9 _, error -\u0026gt; 10 error 11 end) 12 else 13 {:error, \u0026#34;must be a number\u0026#34;} 14 end 15 end Length validation Length is just a number, so we can reuse number validation. We just have to check if given value is one of support types: list, map, string, and tuple\nWe will implement get_length/1 function to get data length first.\n1 @spec get_length(any) :: pos_integer() | {:error, :wrong_type} 2 defp get_length(param) when is_list(param), do: length(param) 3 defp get_length(param) when is_binary(param), do: String.length(param) 4 defp get_length(param) when is_map(param), do: param |\u0026gt; Map.keys() |\u0026gt; get_length() 5 defp get_length(param) when is_tuple(param), do: tuple_size(param) 6 defp get_length(_param), do: {:error, :wrong_type} Then we do number validation on the length value\n1 @spec validate_length(support_length_types, keyword()) :: :ok | error 2 def validate_length(value, checks) do 3 with length when is_integer(length) \u0026lt;- get_length(value), 4 # validation length number 5 :ok \u0026lt;- validate_number(length, checks) do 6 :ok 7 else 8 {:error, :wrong_type} -\u0026gt; 9 {:error, \u0026#34;length check supports only lists, binaries, maps and tuples\u0026#34;} 10 11 {:error, msg} -\u0026gt; 12 # we prepend length to message return by validation number to get full message 13 # like: \u0026#34;length must be equal to x\u0026#34; 14 {:error, \u0026#34;length #{msg}\u0026#34;} 15 end 16 end Combine all validation Most of time you want to use multiple valitions on the data. So we will add a function that do multiple validation\nWe define a simple structure for validation first. This is our validate function spec\n1 @spec validate(any(), keyword()) :: :ok | {:error, messages} Then we can use it like this:\n1Checky.validate(value, type: :string, format: ~r/\\d\\d.+/, length: [min: 8, max: 20]) Validations is a keyword list with short name for validation:\n :type -\u0026gt; validate_type :format -\u0026gt; validate_format :in -\u0026gt; validate_inclusion :not_in -\u0026gt; validate_exclusion :number -\u0026gt; validate_number :length -\u0026gt; validate_length  Define mapping function:\n1 defp get_validator(:type), do: \u0026amp;validate_type/2 2 defp get_validator(:format), do: \u0026amp;validate_format/2 3 defp get_validator(:number), do: \u0026amp;validate_number/2 4 defp get_validator(:length), do: \u0026amp;validate_length/2 5 defp get_validator(:in), do: \u0026amp;validate_inclusion/2 6 defp get_validator(:not_in), do: \u0026amp;validate_exclusion/2 7 defp get_validator(name), do: {:error, \u0026#34;validate_#{name}is not support\u0026#34;} 8 Go checking validations one by one\n1 def validate(value, validators) do 2 do_validate(value, validators, :ok) 3 end 4 5 defp do_validate(_, [], acc), do: acc 6 7 # check validations one by one 8 defp do_validate(value, [h | t] = _validators, acc) do 9 case do_validate(value, h) do 10 :ok -\u0026gt; do_validate(value, t, acc) 11 error -\u0026gt; error 12 end 13 end 14 15 # validate single validation 16 defp do_validate(value, {validator, opts}) do 17 case get_validator(validator) do 18 {:error, _} = err -\u0026gt; err 19 validate_func -\u0026gt; validate_func.(value, opts) 20 end 21 end Conclusion Writing a validation module is not so hard. Now you can add more validations to fit your need. As I promised, this is the full source of the module with custom validation fucntion. https://github.com/bluzky/valdi/blob/main/lib/valdi.ex\nThank you for reading to the end of this post. Please leave me a comment.\n","date":"31","image":"/img/build-json-validator.webp","permalink":"https://techblog.onpoint.vn/blog/2021-07-31-build-elixir-validator-from-scratch/","tags":["elixir","validation"],"title":"How to build an Elixir validator from scratch"},{"categories":null,"contents":"In my previous article, I introduced my library call JsonView to render json response easier. You can read it here: Render Ecto schema to json with relationships with JsonView\nToday I will guide you to write your own Json render view. Let\u0026rsquo;s start.\nNow for example I have a Blog app with User Category , Post and Comment schemas.\nThis is PostView which is generated by Phoenix\n1defmodule MyBlogWeb.PostView do 2 use MyBlogWeb, :view 3 alias MyBlogWeb.PostView 4 5 def render(\u0026#34;index.json\u0026#34;, %{posts: posts}) do 6 %{data: render_many(posts, PostView, \u0026#34;post.json\u0026#34;)} 7 end 8 9 def render(\u0026#34;show.json\u0026#34;, %{post: post}) do 10 %{data: render_one(post, PostView, \u0026#34;post.json\u0026#34;)} 11 end 12 13 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 14 %{id: post.id, 15 title: post.title, 16 description: post.description, 17 content: post.content, 18 cover: post.cover, 19 is_published: post.is_published} 20 end 21end 22 Let\u0026rsquo;s improve it\n1. Use Map.take 1... 2def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 3\tMap.take(post, [:id, :title, :description, :content, :cover, :is_published]) 4end 5... This way you don\u0026rsquo;t have to write much code every time you add a new attribute.\n2. Render custom field You may want to:\n Format some field value instead of return original value Calculate virtual field  Normally you will do this:\n1\tdef render(\u0026#34;post.json\u0026#34;, %{post: post}) do 2 post 3 |\u0026gt; Map.take([:id, :title, :description, :content, :cover, :is_published]) 4 |\u0026gt; Map.merge(%{ 5 comment_count: render_comment_count(post), 6 author_name: render_author_name(post) 7 }) 8 end 9 10 def render_comment_count(post) do 11 ... 12 end 13 14 def render_author_name(post) do 15 ... 16 end Or you can reduce a bit of code by using pattern matching to render custom field value\n1\tdef render(\u0026#34;post.json\u0026#34;, %{post: post}) do 2 post 3 |\u0026gt; Map.take([:id, :title, :description, :content, :cover, :is_published]) 4 |\u0026gt; Map.merge(render_custom_fields(post, [:comment_count, :author_name])) 5 end 6 7 defp render_custom_fields(struct, fields) do 8 Enum.map(fields, fn field -\u0026gt; 9 {field, render_field(field, struct)} 10 end) 11 |\u0026gt; Enum.into(%{}) 12 end 13 14 defp render_field(:comment_count, post) do 15 ... 16 end 17 18 defp render_field(:author_name, post) do 19 ... 20 end Now every time you add a new custom field, just add field name to the list, and define a render_field/2 function\n3. Render relation ship You may want to return the whole object of author. For example you have a view UserView so you can do:\n1 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 2 post 3 ... 4 |\u0026gt; Map.merge(%{ 5 author: render_one(post.author, MyBlogWeb.UserView, \u0026#34;user.json\u0026#34;) 6 }) 7 end It requires that author must be loaded, if not, you will get this error\n** (KeyError) key :id not found in: #Ecto.Association.NotLoaded\u0026lt;association :author is not loaded\u0026gt; You can handle it by pattern matching against Ecto.Association.NotLoaded\n1 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 2 post 3 ... 4 |\u0026gt; Map.merge(%{ 5 author: render_relationship(post.author, MyBlogWeb.UserView, \u0026#34;user.json\u0026#34;) 6 }) 7 end 8 9 defp render_relationship(%Ecto.Association.NotLoaded{}, _, _), do: nil 10 11 defp render_relationship(relation, view, template) do 12 render_one(relation, view, template) 13 end And it only render relations struct if loaded, otherwise it is set to nil.\nNow you can improve it to render list of relationships\n1def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 2 post 3 ... 4 |\u0026gt; Map.merge( 5 render_relationship(post, [ 6 {:author, MyBlogWeb.UserView, \u0026#34;user.json\u0026#34;}, 7 {:comments, MyBlogWeb.CommentView, \u0026#34;comment.json\u0026#34;} 8 ]) 9 ) 10end 11 12defp render_relationship(struct, relationships) do 13 Enum.map(relationships, fn {field, view, template} -\u0026gt; 14 {field, render_relationship(Map.get(struct, field), view, template)} 15 end) 16 |\u0026gt; Enum.into(%{}) 17end 18 19defp render_relationship(%Ecto.Association.NotLoaded{}, _, _), do: nil 20 21defp render_relationship(relations, view, template) when is_list(relations) do 22 render_many(relations, view, template) 23end 24 25defp render_relationship(relation, view, template) do 26 render_one(relation, view, template) 27end With this way you can handle both single struct and list of struct.\n4. Combines these helper functions You can combine them all in one function and only need to pass field definition to this function\n1@fields [:id, :title, :description, :content, :cover, :is_published] 2 @custom_fiels [:comment_count, :author_name] 3 @relationships [ 4 {:author, MyBlogWeb.UserView, \u0026#34;user.json\u0026#34;}, 5 {:comments, MyBlogWeb.CommentView, \u0026#34;comment.json\u0026#34;} 6 ] 7 8 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 9 render_json(post, @fields, @custom_fiels, @relationships) 10 end 11 12 def render_json(struct, fields, custom_fields \\\\ [], relationships \\\\ []) do 13 struct 14 |\u0026gt; Map.take(fields) 15 |\u0026gt; Map.merge(render_custom_fields(struct, custom_fields)) 16 |\u0026gt; Map.merge(render_relationship(struct, relationships)) 17 end Move them to a helper These functions are the same for every view, so let\u0026rsquo;s move these code to a helper module JsonViewHelper\n1defmodule JsonViewHelper do 2 import Phoenix.View, only: [render_one: 3, render_many: 3] 3 4 def render_json(struct, view, fields, custom_fields \\\\ [], relationships \\\\ []) do 5 struct 6 |\u0026gt; Map.take(fields) 7 |\u0026gt; Map.merge(render_custom_fields(struct, view, custom_fields)) 8 |\u0026gt; Map.merge(render_relationship(struct, relationships)) 9 end 10 11 defp render_custom_fields(struct, view, fields) do 12 Enum.map(fields, fn field -\u0026gt; 13 {field, view.render_field(field, struct)} 14 end) 15 |\u0026gt; Enum.into(%{}) 16 end 17 18 defp render_relationship(struct, relationships) do 19 Enum.map(relationships, fn {field, view, template} -\u0026gt; 20 {field, render_relationship(Map.get(struct, field), view, template)} 21 end) 22 |\u0026gt; Enum.into(%{}) 23 end 24 25 defp render_relationship(%Ecto.Association.NotLoaded{}, _, _), do: nil 26 27 defp render_relationship(relations, view, template) when is_list(relations) do 28 render_many(relations, view, template) 29 end 30 31 defp render_relationship(relation, view, template) do 32 render_one(relation, view, template) 33 end 34end Here I modify render_custom_fields a bit, because we call render_field to render custom field, so we have pass the view module as second parameter, so we can use the module to invoke those render_field that we define.\nAnd now render json response is much simple:\n1defmodule BlogeeWeb.PostView do 2\t... 3 @fields [:id, :title, :description, :content, :cover] 4 @custom_fields [:status] 5 @relationships [ 6 {:author, BlogeeWeb.UserView, \u0026#34;basic_info.json\u0026#34;}, 7 {:category, BlogeeWeb.CategoryView, \u0026#34;category.json\u0026#34;} 8 ] 9 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 10 JsonViewHelper.render_json(post, __MODULE__, @fields, @custom_fields, @relationships) 11 end 12 13 def render_field(:status, post) do 14 if post.is_published do 15 \u0026#34;published\u0026#34; 16 else 17 \u0026#34;draft\u0026#34; 18 end 19 end 20end Hooray Thank you for reading to the end of this article. Hope that this can help. If you want to use render hook, take a look at my github for full code\nhttps://github.com/bluzky/json_view\n","date":"23","image":"/img/build-a-json-view.png","permalink":"https://techblog.onpoint.vn/blog/2021-07-23-build-a-json-view-yourself/","tags":["elixir","phoenix","json view"],"title":"Build your own library to render json response in Phoenix"},{"categories":null,"contents":"When writing API with Phoenix and render json to client,\n For some fields I want to keep it original value. For some fields, I want to do some calculation or format data before returning. And I want to render Ecto association too.  An while working on an project at OnPoint I have build a little module that helps to do this easier.\nI have extract that module and release as a package named JsonView. Its source code is hosted on github:\nhttps://github.com/bluzky/json_view\nYou can use it with Phoenix.View or use it independently. It helps to manipulate data, and handle rendering association automatically.\nI have published an article on how to write it A better way to render json response in Elixir Phoenix\nLet\u0026rsquo;s take a look.\nFirst define view modules\n1 defmodule MyApp.UserView do 2 use JsonView 3 def render(\u0026#34;user.json\u0026#34;, %{user: user}) do 4 render_json(user, [:first_name, :last_name, :vatar], [], []) 5 end 6 end 7 8 defmodule MyApp.PostView do 9 use JsonView 10 11 # define which fields return without modifying 12 @fields [:title, :content, :excerpt, :cover] 13 # define which fields that need to format or calculate, you have to define `render_field/2` below 14 @custom_fields [:like_count] 15 # define which view used to render relationship 16 @relationships [author: MyApp.UserView] 17 18 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 19 # 1st way if `use JsonView` 20 render_json(post, @fields, @custom_fields, @relationships) 21 end 22 23 def render_field(:like_count, item) do 24 # load like_count from some where 25 end 26 end And then use it\n1post = %Post{ 2\ttitle: \u0026#34;Hello JsonView\u0026#34;, 3\texcerpt: \u0026#34;Now you can render Json easier\u0026#34;, 4\tcontent: \u0026#34;Install and put it to work\u0026#34;, 5\tcover: nil, 6\tinserted_at: ~N[2021-07-05 00:00:00], 7\tupdated_at: ~N[2021-07-09 00:00:00], 8\tauthor: %User{ 9\tfirst_name: \u0026#34;Daniel\u0026#34;, 10\tlast_name: \u0026#34;James\u0026#34;, 11\temail: \u0026#34;daniel@example.com\u0026#34;, 12\tavatar: nil, 13\tinserted_at: ~N[2021-06-30 00:00:00] 14\tupdated_at: ~N[2021-07-02 00:00:00] 15\t} 16} 17 18MyApp.PostView.render(\u0026#34;post.json\u0026#34;, %{post: post}) 19 20# or invoke from PostController 21render(conn, \u0026#34;post.json\u0026#34;, post: post) This is the result that you can use to return from PhoenixController\n1%{ 2\ttitle: \u0026#34;Hello JsonView\u0026#34;, 3\texcerpt: \u0026#34;Now you can render Json easier\u0026#34;, 4\tcontent: \u0026#34;Install and put it to work\u0026#34;, 5\tcover: nil, 6 like_count: nil, 7\tauthor: %{ 8\tfirst_name: \u0026#34;Daniel\u0026#34;, 9\tlast_name: \u0026#34;James\u0026#34; 10\t} 11} If you have any feedback, please comment or create an issue.\nIn the next post I will go through step by step to write this library.\n","date":"10","image":"/img/json-view.png","permalink":"https://techblog.onpoint.vn/blog/2021-07-10-render-response-json-view/","tags":["elixir","phoenix","json view","ecto"],"title":"Elixir phoenix - Render Ecto schema to json with relationships"},{"categories":null,"contents":"What is Guard in Elixir In previous post, I explain what is Pattern Matching and how to use it.\nElixir pattern matching in a nutshell\nPattern matching is so cool but some time I want to do some more complicated checking. With pattern matching I can easily do this\n1def can_access?(%User{paid_user: true}), do: true Yes, Pattern matching can do check value with exact value easily. But for example, I want to allow user with level \u0026gt; 25 to access.\nHow to do that check with Pattern matching?\nPattern matching as it\u0026rsquo;s named, it is used to match data against pattern. If you want to do more complex check, you need another guy. That is where guard shines, it is complement for Pattern Matching\n1def can_access?(%User{level: level}) when level \u0026gt; 25, do: true What is guard   Guard is a complement to your pattern matching to do more complex check.\n  Guard expression is invoke after pattern mattching\n  In many cases, Guard and Pattern matching can produce the same result, so use which you like.\n  1# sum on empty list 2# pattern matching 3def sum_list([] = _input), do: 0 4 5# guard 6def sum_list(input) when input == [], do: 0 Some example\n  Check primitive type\n1def sum(a, b) when is_integer(a) and is_integer(b) do 2\ta + b 3end   Check value is nil/ not nil\n1def string_length(string) when not is_nil(string) do 2\t# your code 3end   Check if input in a list of allowed values\n1def can_edit?(%User{role: role}) when role in [\u0026#34;admin\u0026#34;, \u0026#34;moderator\u0026#34;] do 2\ttrue 3end   And many more \u0026hellip;\n  Where to use guard? Where you can use Pattern Matching, you can use Guard\n  case block\n1case value do 2\tx when is_binary(x) -\u0026gt; String.to_integer(x) 3\tx when is_integer(x) -\u0026gt; x 4\t_ -\u0026gt; raise \u0026#34;Invalid value\u0026#34; 5end   with block\n1with user when not is_nil(user) \u0026lt;- find_user(id) do 2\t# your code block 3end   function clause as our example above\n  Why my guard not work? Not all expression will work with guard. Only a list of built-in guard and combination of them work in guard expression.\nCheck this from https://hexdocs.pm/elixir/guards.html#list-of-allowed-expressions\n  comparison operators (==, !=, ===, !==, \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;=) strictly boolean operators (and, or, not). Note \u0026amp;\u0026amp;, ||, and ! sibling operators are not allowed as they\u0026rsquo;re not strictly boolean - meaning they don\u0026rsquo;t require arguments to be booleans arithmetic unary and binary operators (+, -, +, -, *, /) in and not in operators (as long as the right-hand side is a list or a range) \u0026ldquo;type-check\u0026rdquo; functions (is_list/1, is_number/1, etc.) functions that work on built-in datatypes (abs/1, map_size/1, etc.)   Can I define my own guard? Yes you can define a guard with defguard/1 and defguardp/1 . But you should only define your own guard if you have a really really reasonable reason to do so.\nIn my experience, I have never defined a guard my own, built-in guards are too enough.\nConclustion With Pattern matching and Guard, you have a super powerful combo in your hand. Let\u0026rsquo;s code!\n","date":"30","image":"/img/elixir-guard.webp","permalink":"https://techblog.onpoint.vn/blog/2021-06-30-elixir-for-beginner-all-you-need-to-know-about-guard/","tags":["elixir","elixir-beginner"],"title":"Elixir for Beginner - All you need to know about guard"},{"categories":null,"contents":"If you are new to Elixir, Pattern Matching may be something strange to you. When you get familiar with it, you will know how powerful it is. And I\u0026rsquo;m sure that you will definite love it. Pattern matching is used everywhere in your elixlir code . And I would bring it to other language that I use ( if I can :D)\nBut it\u0026rsquo;s not so hard.\nWhat does Pattern Matching do? Give you a variable/value, you might want\n Check if data type is match your expected data type Check if structure of data match your expected data structure Assign matching part of data to a variable  And pattern matching do all these thing for you. Just look at some example.\nWhen you try these example, it will raise exception if data doesn\u0026rsquo;t match against the pattern. In real Elixir app, you won\u0026rsquo;t use it this way, check Where it is used at the end of this article\nPattern matching with Map/Struct 1. Check if this data is a map\n1%{} = params 2. Check if data is a map and has key email and email value is zoo@example.com\n1%{\u0026#34;email\u0026#34; =\u0026gt; \u0026#34;zoo@example.com\u0026#34;} = params 3. Check if data is a map and has key email, if matchs pattern, assign value of key email to variable my_email\n1%{\u0026#34;email\u0026#34; =\u0026gt; my_email} = params 4. Check if data is a map and has key email, I don\u0026rsquo;t want to extract value\nuse _ to ignore value\n1%{\u0026#34;email\u0026#34; =\u0026gt; _} = params 5. Pattern matching nested map\n1%{\u0026#34;address\u0026#34; =\u0026gt; %{\u0026#34;city\u0026#34; =\u0026gt; city}} = params 6. Check if data is type struct User\n1%User{} = params  The rest is same with map. Struct is basically a map with atom key.\n Pattern matching with List 1. Check if data is empty lis\n1[] = params 2. Check if data is a list and not empty\n1[_|_] = params 3. Check if data is exact list\n1[1, 2] = params 4. Check if data is list and extract first element and remaining\n1[first_element | remaining] = params Pattern matching with Tuple You don\u0026rsquo;t have much pattern to match against tuple\n1. Check if data is tuple of 2 elements\n1{_, _} = params 2. Check if data is tuple and has specific value\n1{:ok, data} = result 2# you use this most of time Where to use pattern matching 1. case clause\n1case user do 2\t%User{is_active: true} -\u0026gt; \u0026#34;Log you in\u0026#34; 3\t%User{is_active: false} -\u0026gt; \u0026#34;Check your email\u0026#34; 4\t_others -\u0026gt; \u0026#34;Not a user\u0026#34; 5end 2. with clause\n1with {:ok, user} \u0026lt;- create_user(params) do 2\t# your code 3end 3. function\n1def is_admin(%User{role: \u0026#34;admin\u0026#34;}), do: true 2def is_admin(%User{role: _}), do: false 3def is_admin(_), do: raise \u0026#34;Not a user\u0026#34; Conclusion At first, it\u0026rsquo;s a bit strange to grasp, but gradually you can live without it. It is one of Elixir\u0026rsquo;s features that I love most. And I think you will. Using it more and its power is in your hand.\n","date":"29","image":"/img/pattern-matching.png","permalink":"https://techblog.onpoint.vn/blog/2021-06-29-elixir-pattern-matching-in-a-nut-shell/","tags":["elixir","elixir-beginning"],"title":"Elixir Pattern Matching in a nut shell"},{"categories":null,"contents":"The story At our company, OnPoint, we are building an ecommerce website using Phoenix Framework. And I am working on admin to manage product, orders \u0026hellip; All the listing pages need a filter and this filter change frequently, operation team wants to add this field, order by that field. And each time they change their requirements I have to update query code.\nMy team use Django Admin before, they support an easy way to compose query directly from the URL. You don\u0026rsquo;t have to change code on the back-end. It\u0026rsquo;ll be great if I can do it with Phoenix.\nWhat it should have:\n Support basic query operator: \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;=, =, !=, like, ilike, in Query join table Can sort result  This is the result after some night of work:\nhttps://github.com/bluzky/querie\nHow it work  I define a simple rule for passing parameter from client side. The key must follow format [column]__[operator]=[value]. On the server side, it is parsed to {operator, {column, value}} with appropriate data type Then it is passed to a filter function to build Ecto query dynamically  You can try with example project to see how it works.\nHow to use it 1. Define a filter schema For example you have a Post schema:\n1defmodule Example.Content.Post do 2 use Ecto.Schema 3 import Ecto.Changeset 4 5 def state_enum(), do: ~w(draft published archived trash) 6 7 schema \u0026#34;posts\u0026#34; do 8 field(:content, :string) 9 field(:state, :string, default: \u0026#34;draft\u0026#34;) 10 field(:title, :string) 11 field(:view_count, :integer, default: 0) 12 belongs_to(:category, Example.PostMeta.Category) 13 belongs_to(:author, Example.Account.User) 14 end 15end And you want to filter the Post by title, state, view_count. This is the filter schema:\n1@schema %{ 2 title: :string, 3 state: :string, # short form 4 view_count: [type: :integer] # long form 5} 2. Parse request parameters and build the query Use Querie.parse/2 to parse request parameters with your schema\n1alias Example.Content.Post 2 3def index(conn, params) do 4 with {:ok, filter} \u0026lt;- Querie.parse(@schema, params) do 5\tquery = Querie.filter(Post, filter) 6\t# Or you can pass a query like this 7\t# query = from(p in Post, where: ....) 8\t# query = Querie.filter(query, filter) 9\tposts = Repo.all(query) 10\t# do the rendering here 11 else 12 {:error, errors} -\u0026gt; 13\tIO.puts(inspect(errors) 14\t# or do anything with error 15\t# error is a list of tuple {field, message} 16 end 17end 3. Compose URL Then from client side you can send a form:\n1\u0026lt;form action=\u0026#34;/posts\u0026#34;\u0026gt; 2 \u0026lt;label\u0026gt;Titlte\u0026lt;/label\u0026gt; 3 \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title__icontains\u0026#34;\u0026gt; 4 \u0026lt;label\u0026gt;State\u0026lt;/label\u0026gt; 5 \u0026lt;select name=\u0026#34;state\u0026#34;\u0026gt; 6 \u0026lt;option value=\u0026#34;draft\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; 7 \u0026lt;option value=\u0026#34;published\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; 8 \u0026lt;option value=\u0026#34;trashed\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; 9 \u0026lt;/select\u0026gt; 10 \u0026lt;label\u0026gt;View count greater than\u0026lt;/label\u0026gt; 11 \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;view_count__ge\u0026#34;\u0026gt; 12\u0026lt;/form\u0026gt; Or directly from URL with data like this:\nhttp://localhost:4000/posts?title__icontains=elixir\u0026amp;state=published\u0026amp;view_count__ge=100 Enter and see the result\nQuery joined table It quite simple to filter result with filter on joined tables.\n1. Update your query Querie support ref operator to join tables. For example you want to query Post by author whose email contains sam the query would be:\n?author__ref[email__icontains]=sam 2. Update your schema 1alias Example.Account.User 2 3@schema %{ 4 title: :string, 5 state: :string, 6 view_count: [type: :integer], 7 author: [ 8\ttype: :ref, # this references to another schema 9\tmodel: User, # which schema to query 10\tschema: %{ # define filter schema for User 11\temail: :string 12\t} 13\t] 14} For more query options, please read document\nIf you have any suggestion, please leave a comment or open an issuse on Github.\nThanks for reading.\n","date":"30","image":"/img/request-to-query.png","permalink":"https://techblog.onpoint.vn/blog/2020-10-30-compose-ecto-query-from-client/","tags":["elixir","phoenix","query","ecto","querie"],"title":"Compose Ecto Query From Client"},{"categories":null,"contents":"**Version mới của thư viện Tarams không tương thích với bản cũ. Các bạn đọc bài mới ở đây nhé How to validate request params in Phoenix\nYêu cầu chuẩn hoá và validate các tham số truyền lên từ client là yêu cầu cơ bản khi xây dựng API Web. Mình đã có một bài hướng dẫn sử dụng Ecto.Changeset để chuẩn hoá trong bài viết này:\nParse và validate request param trong Phoenix với Ecto \nTrong bài viết này, mình sẽ hướng dẫn một cách ngắn và đơn giản hơn bằng cách sử dụng thư viện sẵn có Tarams. Thư viện này thực ra là sử dụng lại Ecto.Changeset nhưng nó giúp cho chúng ta không phải lặp lại quá nhiều code như khi dùng Ecto.Changeset\nMột vài tính năng thú vị của Tarams:\n Cung cấp cách thức đơn giản để định nghĩa các cấu trúc tham số Cho phép định nghĩa các giá trị default động Cho phép định nghĩa các hàm để cast giá trị về đúng kiểu dữ liệu Định nghĩa hàm để validate dữ liệu  Sau đây là cách sử dụng Tarams. Ví dụ chúng ta đang viết API để cập nhật profile của nhân viên. Yêu cầu là\nemail: bắt buộc, đúng định dạng first_name: bắt buộc last_name: bắt buộc birthday: không bắt buộc, kiểu ngày tháng title: không bắt buộc start_date: ngày bắt đầu làm việc, ngày tháng, mặc định là ngày hiện tại 1. Định nghĩa cấu trúc của tham số truyền lên khá đơn giản 1@schema %{ 2 email: [type: :string], 3 first_name: [type: :string], 4 last_name: [type: :string], 5 title: :string, 6 birth_day: [type: :date], 7 start_date: [type: :date] 8} Schema đơn giản chỉ là một map với key là tên field và value là 1 list option của field đó.\n2. Bây giờ thêm các ràng buộc  Để đánh dấu 1 trường là bắt buộc, thêm option required: true Taram cũng cho phép validate data sử dụng lại các hàm validate của Changeset  1@schema %{ 2 email: [type: :string, required: true, validate: {:format, ~r/@/}], 3 first_name: [type: :string, required: true], 4 last_name: [type: :string, required: true], 5 title: :string, 6 birth_day: [type: :date], 7 start_date: [type: :date] 8} 3. Bây giờ thì set các giá trị default default có thể là 1 giá trị hoặc 1 hàm. Mỗi khi parse tham số thì hàm này sẽ được gọi để lấy giá trị mặc định\n1@schema %{ 2 ... 3 title: [type: :string, default: \u0026#34;staff\u0026#34;], 4 birth_day: [type: :date], 5 start_date: [type: :date, default: \u0026amp;Timex.today/0] 6} 4. Cast các giá trị tham số về đúng kiểu Nhiều các giá trị tham số truyền lên phải được chuyển về đúng các loại dữ liệu phức tạp như ngày tháng, list. Ví dụ ngày tháng truyền lên là string 01/12/1994 thì phải chuyển về kiểu date để sử dụng lại được. Tarams hỗ trợ định nghĩa 1 hàm custom để cast giá trị, hàm này trả về\n {:ok, value} nếu parse thành công {:error, error_message} nếu thất bại  1def parse_date(date_str) do 2 Timex.parse(date_str, \u0026#34;{0D}/{0M}/{YYYY}\u0026#34;) 3end 4 5@schema %{ 6 ... 7 title: [type: :string, default: \u0026#34;staff\u0026#34;], 8 birth_day: [type: :date, cast_func: \u0026amp;parse_date/1], 9 start_date: [type: :date, default: \u0026amp;Timex.today/0] 10} 5. Bây giờ sử dụng nào 1def update(conn, params) do 2 with {:ok, user_data} \u0026lt;- Tarams.parse(@schema, params) do 3 # do anything with your params 4 # access data bằng atom key: user_data.email 5 else 6 {:error, changset} -\u0026gt; # return params error 7 end 8end Hàm parse sẽ parse và validate dữ liệu. Nếu mọi thứ đều ổn, sẽ trả về {:ok, data} và ngược lại thì trả về {:error, changeset}.\nDone! Code của bạn sẽ trở nên đơn giản và ngắn gọn hơn nhiều\n","date":"01","image":"/img/tarams-parse.png","permalink":"https://techblog.onpoint.vn/blog/2020-10-01parse-validate-data-with-tarams/","tags":["elixir","ecto","phoenix","tarams"],"title":"Chuẩn hoá và validate dữ liệu trong Phoenix với thư viện Tarams"},{"categories":null,"contents":"Khi viết các API hoặc cả các endpoint thì thông thường chúng ta sẽ có một số nhu cầu:\n Chỉ cho phép một số các tham số xác định được truyền vào. Chuyển các tham số về kiểu dữ liệu mong muốn Validate các tham số theo yêu cầu  Bài viết này sẽ hướng dẫn các bạn giải quyết các vấn đề trên sử dụng Ecto.Changeset\nThư viện Ecto đã cung cấp sẵn cho chúng ta module Changeset. Nó hỗ trợ việc cast các tham số về đúng kiểu dữ liệu mong muốn, nó cũng hỗ trợ các phương thức để validate các tham số yêu cầu, và nó cũng cho phép bạn giới hạn tham số nào được truyền vào.\nVà sau đây là một ví dụ sử dụng Chageset để validate các tham số khi filter các đơn hàng.\n1. Đầu tiên bạn phải định nghĩa một schema 1defmodule MyApp.OrderFilterParams do 2 use Ecto.Schema 3 import Ecto.Changeset 4 5 schema \u0026#34;order_filter_params\u0026#34; do 6 field :keyword, :string 7 field :category_id, :integer 8 field :status, :string 9 field :start_date, :utc_datetime 10 field :end_date, :utc_datetime 11 end 12end 2. Cast và validate Sau đó phải định nghĩa một hàm để thực hiện việc cast tham số và validate changeset.\n1defmodule MyApp.OrderFilterParams do 2 3 ... 4 5 @required ~w(category_id start_date) 6 @optional ~w(keyword status end_date) 7 8 def changeset(changeset_or_model, params) do 9 cast(changeset_or_model, params, @required ++ @optional) 10 |\u0026gt; validate_required(@required) 11 end 12end 3. Set giá trị default động Nếu bạn muốn sử dụng các giá trị default động, ví dụ như mặc định ngày kết thúc là ngày hiện tại, các bạn phải định nghĩa một function để set giá trị mong muốn.\n1defmodule MyApp.OrderFilterParams do 2 3 ... 4 5 def changeset(changeset_or_model, params) do 6 cast(changeset_or_model, params, @required ++ @optional) 7 |\u0026gt; validate_required(@required) 8 |\u0026gt; set_default_end_date() 9 end 10 11 defp set_defaut_end_date(changeset) do 12 end_date = get_change(changeset, :end_date) 13 if is_nil(end_date) do 14 put_change(changeset, :end_date, Timex.today()) 15 else 16 changeset 17 end 18 end 19end 4. Sử dụng Params schema 1defmodule MyApp.OrderController do 2 use MyApp, :controller 3 alias MyApp.OrderFilterParams 4 5 def index(conn, params) do 6 changeset = OrderFilterParams.changeset(%OrderFilterParams{}, params) 7 8 if changeset.valid? do 9 strong_params = Ecto.Changeset.apply_changes(changeset) 10\tIO.put(strong_params.keyword) 11 # Do something with your params 12 else 13 # handle error 14 end 15 end 16end 17 Rất đơn giản đúng không, nếu bạn đã sử dụng Ecto thì việc này chỉ là ruồi muỗi. Tuy nhiên đơn giản thì phải có thứ đánh đổi chứ.\nVài thứ mà bạn sẽ thấy bất tiện 1. Lượng code mà bạn phải viết quá nhiều. Thử tưởng tượng mỗi API bạn lại phải định nghĩa thêm một Module params cho nó thì phức tạp vl.\nBạn có thể sử dụng schemaless, nhưng mà function của bạn sẽ rối nùi lên vì code logic và code xử lý params nó không liên quan gì tới nhau cả. Và bạn thì kiểu như đổ sting vào cơm để ăn vậy.\n2. Thiếu linh hoạt. Điều này cũng đúng vì mục đích chính của Ecto là phục vụ cho việc định nghĩa các schema cho database.\nĐơn giản như việc định nghĩa giá trị default động như trên, bạn phải viết luôn 1 hàm mới\nTuy nhiên nó cũng có một ưu điểm là bạn không phải sử dụng thêm thư viện của bên thứ ba.\nKết Nếu bạn không cần phải xử lý nhiều ràng buộc liên quan đến tham số của request thì đơn giản là cứ dùng Changeset thôi.\nNếu bạn muốn nhanh gọn hơn thì trên Hex có một số thư viện để hỗ trợ định nghĩa param đơn giản hơn, ví dụ như https://github.com/bluzky/tarams/\nThư viện này cung cấp cách thức đơn giản và nhanh chóng hơn để định nghĩa param cho API. Mình sẽ viết bài hướng dẫn sau.\n","date":"26","image":"/img/parse-ecto-phoenix.png","permalink":"https://techblog.onpoint.vn/blog/validate-request-params-phoenix-ecto/","tags":["elixir","ecto","phoenix"],"title":"Parse và validate request param trong Phoenix với Ecto"}]